# AGENTS.md — Vulfram instructions

- Sempre que o usuário comentar sobre um padrão ou regra de desenvolvimento, adicionar ao `AGENTS.md`.
- Variaveis que seguram ownership e não são mais usadas depois ganham sempre o prefixo `_`.
- Se variaveis não forem usadas, devem ser removidas.
- Funções não usadas também são removidas.
- Sempre executar `cargo check --lib` ao final de qualquer implementação para checar erros de compilação.
- Configurações de filtros do pós-processamento devem usar o prefixo `filter_` e a flag `filter_enabled`.
- Demos devem fechar por padrão ao pressionar a tecla Escape.
- Valores de `outline_threshold` devem ficar no intervalo [0, 1) (clamp).
- Arquivos devem ter como alvo no 300 linhas e no máximo 500 linhas. Se passar disso e for possível, dividir em arquivos menores.
- Texturas de cor devem usar formato float (ex.: `rgba16f`) por padrão; depth também pode ser float quando aplicável.
- A árvore do render graph não deve declarar formatos de textura; o core define padrões.
- Sempre atualizar a documentação relacionada ao terminar uma fase.
- Em auditorias futuras, ignorar retenção por recursos host-side sem dispose.
- `scripts/check.sh` roda `cargo check --lib` + valida WGSL.
- Decode de imagens/texturas deve ser assíncrono por padrão; no browser tentar Worker e, se indisponível, usar Promises/async com divisão em chunks para não travar o loop.
- Dispose de recursos em decode deve cancelar (ou, se impossível, aguardar) e descartar o resultado.
- `unwrap` em fluxo de comandos deve ser tratado com rollback e retorno de erro; fora de comandos deve emitir evento de erro.
- Propriedades internas em Rust usam `snake_case`; o serde converte para `camelCase` no host.
- Recursos de áudio devem seguir o mesmo padrão de recursos de textura: IDs lógicos, bind a modelo para emissor/receptor, play com delay opcional e modo (once/loop/reverse/loop-reverse/ping-pong), e bypass de spatialização quando emissor e receptor forem o mesmo modelo.
- O sistema de áudio deve separar resource de source: source e listener são vinculados a modelos; play recebe resourceId e timelineId (default 0), reinicia se timeline já estiver ativo; stop pode receber timelineId.
- Arquitetura de render deve introduzir `Realm`, `Surface` e `RealmGraph`: `RenderGraph` fica intra-Realm; `RealmGraph` auto-gerado entre Realms a partir de Connectors e Presents.
- `CmdRenderGraphSet(windowId, graph)` continua existindo como compat layer e passa a ser alias do RenderGraph do Realm default da window.
- `Surface` deve ser sempre renderizavel e sampleavel (virtual swapchain), com conversoes automaticas de formato/alpha/size e resolve de MSAA quando necessario.
- Composicao inter-Realm ocorre via `PlaneConnector` (3D) e `ViewportConnector` (2D/UI), com roteamento de input via hit-test/raycast e foco/capture.
- `RealmGraph` deve impedir deadlocks: ciclos sao quebrados de forma deterministica com cache `LastGoodSurface` ou `FallbackSurface`; leitura do proprio output corrente e proibida por padrao (permitir apenas `PreviousFrame`).
- Compartilhamento entre janelas deve permitir compor a mesma `Surface` em multiplas windows via layers/mascaras/zIndex/viewports; a composicao pode ser direta na janela ou via embed viewport em UI.
- `zIndex`, `layers`, `blendMode` (antes chamado de mascara) e `rect` ficam no nivel de `Connector`; quando varios conectores apontam para a mesma `Surface`, o `zIndex` ordena as layers e o `rect` define o desenho com regras tipo `position: fixed` do CSS.
