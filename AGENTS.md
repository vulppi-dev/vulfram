# AGENTS.md — Vulfram instructions

- Sempre que o usuário comentar sobre um padrão ou regra de desenvolvimento, adicionar ao `AGENTS.md`.
- Variaveis que seguram ownership e não são mais usadas depois ganham sempre o prefixo `_`.
- Se variaveis não forem usadas, devem ser removidas.
- Funções não usadas também são removidas.
- Sempre executar `cargo check --lib` ao final de qualquer implementação para checar erros de compilação.
- Configurações de filtros do pós-processamento devem usar o prefixo `filter_` e a flag `filter_enabled`.
- Demos devem fechar por padrão ao pressionar a tecla Escape.
- Valores de `outline_threshold` devem ficar no intervalo [0, 1) (clamp).
- Arquivos devem ter como alvo no 300 linhas e no máximo 500 linhas. Se passar disso e for possível, dividir em arquivos menores.
- Texturas de cor devem usar formato float (ex.: `rgba16f`) por padrão; depth também pode ser float quando aplicável.
- A árvore do render graph não deve declarar formatos de textura; o core define padrões.
- Sempre atualizar a documentação relacionada ao terminar uma fase.
- Em auditorias futuras, ignorar retenção por recursos host-side sem dispose.
- `scripts/check.sh` roda `cargo check --lib` + valida WGSL.
- Decode de imagens/texturas deve ser assíncrono por padrão; no browser tentar Worker e, se indisponível, usar Promises/async com divisão em chunks para não travar o loop.
- Dispose de recursos em decode deve cancelar (ou, se impossível, aguardar) e descartar o resultado.
- `unwrap` em fluxo de comandos deve ser tratado com rollback e retorno de erro; fora de comandos deve emitir evento de erro.
- Propriedades internas em Rust usam `snake_case`; o serde converte para `camelCase` no host.
- Recursos de áudio devem seguir o mesmo padrão de recursos de textura: IDs lógicos, bind a modelo para emissor/receptor, play com delay opcional e modo (once/loop/reverse/loop-reverse/ping-pong), e bypass de spatialização quando emissor e receptor forem o mesmo modelo.
- O sistema de áudio deve separar resource de source: source e listener são vinculados a modelos; play recebe resourceId e timelineId (default 0), reinicia se timeline já estiver ativo; stop pode receber timelineId.
- UI deve ser renderizada via egui (wgpu), compatível com native e browser (WebGPU-only).
- UI é host-driven: host define estrutura/props/listeners; core renderiza e retorna eventos.
- UI suporta múltiplos `UiContext` isolados (árvore/estado próprios, tema próprio, render target próprio, input roteado por `screenRect` e `zIndex`).
- IDs de UI são sempre `LogicalId`.
- Atualizações estruturais da UI são por lista ordenada de ops; `root` existe em todo context.
- Sem listener não há evento retornado ao host.
- Animações declarativas são ops (`animate`) para ordem determinística.
- Layout é web-like (`row/col/grid` + `wrap`, `align`, `justify`, gaps).
